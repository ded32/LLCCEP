%{
#include <stdio.h>
#include <stdlib.h>

//#define YYSTYPE ast_node *

int yylex();
int yyerror(char *str);

int pos_x;
%}

%token VAL ID LITERAL 

%token SWITCH CASE DEFAULT WHILE DO FOR CONTINUE BREAK
%token IF ELSE
%token GOTO RETURN

%token OP_CMP_LE OP_CMP_AE OP_CMP_EQ OP_CMP_NE

%token OP_INC OP_DEC

%token OP_OFFSET_L OP_OFFSET_R

%token OP_OFFSET_L_EQ OP_OFFSET_R_EQ
%token OP_ADD_EQ OP_SUB_EQ OP_MUL_EQ OP_DIV_EQ OP_MOD_EQ
%token OP_AND_EQ OP_OR_EQ OP_XOR_EQ

%token TYPEDEF EXTERN STATIC AUTO
%token STRUCT UNION ENUM

%token MANY_DOTS

%token PTR_ACS

%token VOID REAL BOOL TRUE FALSE
%token OP_LOGIC_AND OP_LOGIC_OR

%start MAIN_PARSING_UNIT

%%
PRIME: 
	ID
	| VAL
     	| LITERAL
     	| '(' EXPR ')';

POSTFIX_EXPR: 
	PRIME
	| POSTFIX_EXPR OP_INC
	| POSTFIX_EXPR OP_DEC
	| POSTFIX_EXPR '(' ')'
	| POSTFIX_EXPR '(' ARGS_LIST ')'
	| POSTFIX_EXPR PTR_ACS ID;

ARGS_LIST:
	ASSIGNMENT_EXPR
	| ARGS_LIST ',' ASSIGNMENT_EXPR;

UNARY_EXPR: 
	POSTFIX_EXPR
	| OP_INC UNARY_EXPR
	| OP_DEC UNARY_EXPR
	| UNARY_OP REINTERPRET_EXPR;

UNARY_OP:
	'&'
	| '*'
	| '+'
	| '-';

REINTERPRET_EXPR: 
	TYPE_NAME '(' REINTERPRET_EXPR ')'
	| '(' TYPE_NAME ')' REINTERPRET_EXPR
	| UNARY_EXPR;

TOP_LEVEL_EXPR: 
	REINTERPRET_EXPR
	| TOP_LEVEL_EXPR '*' REINTERPRET_EXPR
	| TOP_LEVEL_EXPR '/' REINTERPRET_EXPR
	| TOP_LEVEL_EXPR '%' REINTERPRET_EXPR;

LOW_LEVEL_EXPR: 
	TOP_LEVEL_EXPR
	| LOW_LEVEL_EXPR '+' TOP_LEVEL_EXPR
	| LOW_LEVEL_EXPR '-' TOP_LEVEL_EXPR;

OFFSET_EXPR: 
	LOW_LEVEL_EXPR /* Zero offset */
	| OFFSET_EXPR OP_OFFSET_L LOW_LEVEL_EXPR
	| OFFSET_EXPR OP_OFFSET_R LOW_LEVEL_EXPR;

COMPARISION_EXPR: 
	OFFSET_EXPR /*to_unsigned > 0*/
	| COMPARISION_EXPR '>' OFFSET_EXPR
	| COMPARISION_EXPR '<' OFFSET_EXPR
	| COMPARISION_EXPR OP_CMP_LE OFFSET_EXPR
	| COMPARISION_EXPR OP_CMP_AE OFFSET_EXPR;

EQUIVALENCY_EXPR: 
	COMPARISION_EXPR
	| EQUIVALENCY_EXPR OP_CMP_EQ COMPARISION_EXPR
	| EQUIVALENCY_EXPR OP_CMP_NE COMPARISION_EXPR;

AND_EXPR: 
	EQUIVALENCY_EXPR
	| AND_EXPR '&' EQUIVALENCY_EXPR;

XOR_EXPR: 
	AND_EXPR
	| XOR_EXPR '^' AND_EXPR;

OR_EXPR: 
	XOR_EXPR
	| OR_EXPR '|' XOR_EXPR;

LOGIC_AND_EXPR: 
	OR_EXPR
	| LOGIC_AND_EXPR OP_LOGIC_AND OR_EXPR;

LOGIC_OR_EXPR:
	LOGIC_AND_EXPR
        | LOGIC_OR_EXPR OP_LOGIC_OR LOGIC_AND_EXPR;

COND_EXPR:
	LOGIC_OR_EXPR
	| LOGIC_OR_EXPR '?' EXPR ':' COND_EXPR;

ASSIGNMENT_EXPR:
	COND_EXPR
	| UNARY_EXPR ASSIGNMENT_OP ASSIGNMENT_EXPR;

ASSIGNMENT_OP:
	'='
	| OP_MUL_EQ
	| OP_DIV_EQ
	| OP_MOD_EQ
	| OP_ADD_EQ
	| OP_SUB_EQ
	| OP_OFFSET_L_EQ
	| OP_OFFSET_R_EQ
	| OP_AND_EQ
	| OP_XOR_EQ
	| OP_OR_EQ;

EXPR:
	ASSIGNMENT_EXPR
	| EXPR ',' ASSIGNMENT_EXPR;

CONST_EXPR:
	COND_EXPR;

DECL_EXPR:
	DECLSPEC ';'
	| DECLSPEC DECL_LIST ';';

DECLSPEC:
	STORE_CLASS
	| STORE_CLASS DECLSPEC
	| TYPESPEC
	| TYPESPEC DECLSPEC;

DECL_LIST_INIT:
	DECL_INIT
	| DECL_LIST ',' DECL_INIT;

DECL_INIT:
	DECLARATOR
	| DECLARATOR '=' INIT;

STORE_CLASS:
	TYPEDEF
	| EXTERN
	| STATIC
	| AUTO;

TYPESPEC:
	VOID
	| REAL
	| BOOL
	| STRUCT_UNION_SPEC
	| ENUM_SPEC
	| TYPE_NAME;

STRUCT_UNION_SPEC:
	STRUCT_UNION ID '{' STRUCT_UNION_DECL_LIST '}'
	| STRUCT_UNION '{' STRUCT_UNION_DECL_LIST '}'
	| STRUCT_UNION ID;

STRUCT_UNION:
	STRUCT
	| UNION;

STRUCT_UNION_DECL_LIST:
	STRUCT_UNION_DECL
	| STRUCT_UNION_DECL_LIST STRUCT_UNION;

STRUCT_UNION_DECL:
	TYPESPEC STRUCT_UNION_DECLARATOR_LIST ';';

STRUCT_UNION_DECLARATOR_LIST:
	STRUCT_UNION_DECLARATOR
	| STRUCT_UNION_DECLARATOR_LIST STRUCT_UNION_DECLARATOR;

STRUCT_UNION_DECLARATOR:
	DECLARATOR
	| ':' CONST_EXPR
	| DECLARATOR ':' CONST_EXPR;

ENUM_SPEC:
	ENUM '{' ENUMERATOR_LIST '}'
	| ENUM ID '{' ENUMERATOR_LIST '}'
	| ENUM ID;

ENUMERATOR_LIST:
	ENUMERATOR
	| ENUMERATOR_LIST ',' ENUMERATOR;

ENUMERATOR:
	ID
	| ID '=' CONST_EXPR;

DECLARATOR:
	PTR DIRECT_DECLARATOR
	| DIRECT_DECLARATOR;

DIRECT_DECLARATOR:
	ID
	| '(' DECLARATOR ')'
	| DIRECT_DECLARATOR '(' ')'
	| DIRECT_DECLARATOR '(' ID_LIST ')'
	| DIRECT_DECLARATOR '(' PARAM_TYPE_LIST ')'
	| DIRECT_DECLARATOR '[' ']'
	| DIRECT_DECLARATOR '[' CONST_EXPR ']';

PTR:
	'*'
	| '*' PTR;

ID_LIST:
	ID
	| ID_LIST ',' ID;

PARAM_TYPE_LIST:
	PARAM_LIST
	| PARAM_LIST ',' MANY_DOTS;

PARAM_LIST:
	PARAM_DECL
	| PARAM_LIST ',' PARAM_DECL;

PARAM_DECL:
	DECLSPEC DECLARATOR
	| DECLSPEC DECLARATOR_ABSTRACT
	| DECLSPEC;	

TYPE_NAME:
	DECLSPEC DECLARATOR_ABSTRACT;

DECLARATOR_ABSTRACT: 
	PTR
	| DIRECT_DECLARATOR_ABSTRACT
	| PTR DIRECT_DECLARATOR_ABSTRACT;

DIRECT_DECLARATOR_ABSTRACT: 
	'(' DECLARATOR_ABSTRACT ')'
	| '[' ']'
	| '[' CONST_EXPR ']'
	| DIRECT_DECLARATOR_ABSTRACT '[' ']'
	| DIRECT_DECLARATOR_ABSTRACT '[' CONST_EXPR ']'
	| '(' ')'
	| '(' PARAM_TYPE_LIST ')'
	| DIRECT_DECLARATOR_ABSTRACT '(' ')'
	| DIRECT_DECLARATOR_ABSTRACT '(' PARAM_TYPE_LIST ')';

INIT: 
	ASSIGNMENT_EXPR
	| '{' INIT_LIST '}'
	| '{' INIT_LIST ',' '}';

INIT_LIST: 
	INIT
	| INIT_LIST ',' INIT;

STATEMENT: 
	STATEMENT_LABELED
	| STATEMENT_COMPOUND
	| STATEMENT_EXPR
	| STATEMENT_SELECTION
	| STATEMENT_ITERATION
	| STATEMENT_JUMP;

STATEMENT_LABELED:
	ID ':' STATEMENT
	| CASE CONST_EXPR ':' STATEMENT
	| DEFAULT ':' STATEMENT;

STATEMENT_COMPOUND: 
	'{' '}'
	| '{' STATEMENT_LIST '}'
	| '{' DECL_LIST '}'
	| '{' DECL_LIST STATEMENT_LIST '}';

DECL_LIST: 
	DECLARATOR
	| DECL_LIST DECLARATOR;

STATEMENT_LIST:
	STATEMENT
	| STATEMENT_LIST STATEMENT
	;

STATEMENT_EXPR: 
	';'
	| EXPR ';';

STATEMENT_SELECTION:
	IF '(' EXPR ')' STATEMENT
	| IF '(' EXPR ')' STATEMENT ELSE STATEMENT
	| SWITCH '(' EXPR ')' STATEMENT;

STATEMENT_ITERATION:
	WHILE '(' EXPR ')' STATEMENT
	| DO STATEMENT WHILE '(' EXPR ')' ';'
	| FOR '(' STATEMENT_EXPR STATEMENT_EXPR STATEMENT_EXPR ')' STATEMENT;

STATEMENT_JUMP:
	GOTO ID ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN EXPR ';';

MAIN_PARSING_UNIT: 
	EXTERN_DECL
	| MAIN_PARSING_UNIT EXTERN DECLARATOR;

EXTERN_DECL: 
	FUNC_DEF
	| DECLARATOR;

FUNC_DEF:
	DECLSPEC DECLARATOR DECL_LIST STATEMENT_COMPOUND
	| DECLSPEC DECLARATOR STATEMENT_COMPOUND
	| DECLARATOR DECL_LIST STATEMENT_COMPOUND
	| DECLARATOR STATEMENT_COMPOUND;
%%

int yyerror(char *str)
{
	fprintf(stderr, "%s:%d:%d: %s:\n"
	                "%s\n", "here should be path", yylineno, pos_x, str, yytext);

	return 0;
}
